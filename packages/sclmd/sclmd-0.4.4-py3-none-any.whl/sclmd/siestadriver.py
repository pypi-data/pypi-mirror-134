#!/usr/bin/env python
# -*- coding: utf-8 -*

import numpy as np
import pysiesta as ps

from sclmd.units import *


class siesta:
    """
    construct necessory information to do a siesta force run

    assuming all the fdf files are available
    """

    def __init__(self, label, xyz, cell, mesh=100., dmtol=0.001,
                 constraints=[], tdir="./", lunit="Ang", eunit="eV"):
        self.md2ang = 0.06466
        self.meshcutoff = mesh
        self.dmtol = dmtol
        self.constraints = constraints
        self.label = label
        # 1D array gives the coordinates of each atom
        # [xi,yi,zi],i=1,na
        self.xyz = np.array([a[1:] for a in xyz], dtype='d').flatten()
        self.els = [a[0] for a in xyz]
        self.conv = self.md2ang*np.array([3*[1.0/np.sqrt(AtomicMassTable[a])]
                                          for a in self.els]).flatten()
        # 1D array gives the unit cell
        # x1,y1,z1,x2,y2,z2,x3,y3,z3
        self.cell = np.array(cell, dtype='d').flatten()
        self.lunit = lunit
        self.eunit = eunit
        self.genfdf(tdir)

    def genfdf(self, tdir="./"):
        """
        generate the fdf files.
        It includes extra fdf files:
            STRUCT.fdf
            Default.fdf
        """
        fname = self.label+".fdf"
        fn = open(fname, "w")

        fn.write("#fdf generated by siesta:genfdf\n")
        fn.write("SystemName   "+self.label+"\n")
        fn.write("SystemLabel   "+self.label+"\n")
        fn.write("MD.TypeOfRUN   forces\n")
        fn.write("MeshCutoff    "+str(self.meshcutoff)+" Ry\n")
        fn.write("DM.Tolerance  "+str(self.dmtol)+"\n\n\n")
        for i in range(len(self.constraints)):
            if i == 0:
                fn.write("%block GeometryConstraints\n")
            fn.write("position from "+str(self.constraints[i][0])+" to\
                     "+str(self.constraints[i][1])+"\n")
            if i == len(self.constraints)-1:
                fn.write("%endblock GeometryConstraints\n")
        fn.write("%include STRUCT.fdf\n")
        #fn.write("%include "+tdir+"MD.fdf\n")
        fn.write("%include "+tdir+"Default.fdf\n")
        fn.close()

    def start(self, npc=1):
        """
        start siesta
        npc - number of cores
        """
        # set units to : Angstrom, eV
        ps.pysiestaunits("Ang", "eV")

        # ps.pysiestalaunch(label, 8, 'mpirun -np')	#parallel siesta
        ps.pysiestalaunch(self.label, npc, 'mpirun -np')  # serial siesta
        # ps.pysiestalaunch(self.label)	#serial siesta
        print("siesta launched!")

        print("running test...")
        #energy,force = ps.pysiestaforce( self.label , self.xyz, self.cell )
        # equilibrium force
        self.initforce()

        # print "siesta equilibrium energy:", energy
        print("siesta equilibrium force:", self.f0)
        print("test finished!")

    def quit(self):
        """
        quit siesta
        """
        print("Quit siesta!")
        ps.pysiestaquit(self.label)
        print("Done!")

    def newx(self, q):
        """
        return the real coordinates from displacements got from MD

        performing unit conversion and remove the mass factor
        """
        return self.xyz + self.conv*q

    def absforce(self, q):
        """
        calculate the force from siesta
        q:  displacement list of all atoms, including those fixed
        """
        energy, force = ps.pysiestaforce(self.label, self.newx(q), self.cell)
        return self.conv*force

    def initforce(self):
        """
        """
        print("Calculate zero displacement force...")
        # equilibrium force
        extq = np.zeros(len(self.xyz))
        self.f0 = self.absforce(extq)

    def force(self, q):
        """
        calculate the relative force 
        q:  displacement list of all atoms, including those fixed
        """
        return self.absforce(q)-self.f0
