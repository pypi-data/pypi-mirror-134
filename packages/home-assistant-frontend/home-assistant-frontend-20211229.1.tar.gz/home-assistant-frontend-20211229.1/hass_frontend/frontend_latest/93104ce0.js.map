{"version":3,"file":"93104ce0.js","mappings":";;AAoEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAlDA","sources":["webpack://home-assistant-frontend/./src/components/ha-hls-player.ts"],"sourcesContent":["import type HlsType from \"hls.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { nextRender } from \"../common/util/render-status\";\nimport { getExternalConfig } from \"../external_app/external_config\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\ntype HlsLite = Omit<\n  HlsType,\n  \"subtitleTrackController\" | \"audioTrackController\" | \"emeController\"\n>;\n\n@customElement(\"ha-hls-player\")\nclass HaHLSPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public url!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"video\") private _videoEl!: HTMLVideoElement;\n\n  @state() private _error?: string;\n\n  private _hlsPolyfillInstance?: HlsLite;\n\n  private _exoPlayer = false;\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._startHls();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._cleanUp();\n  }\n\n  protected render(): TemplateResult {\n    if (this._error) {\n      return html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`;\n    }\n    return html`\n      <video\n        ?autoplay=${this.autoPlay}\n        .muted=${this.muted}\n        ?playsinline=${this.playsInline}\n        ?controls=${this.controls}\n      ></video>\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    const urlChanged = changedProps.has(\"url\");\n\n    if (!urlChanged) {\n      return;\n    }\n\n    this._cleanUp();\n    this._startHls();\n  }\n\n  private async _getUseExoPlayer(): Promise<boolean> {\n    if (!this.hass!.auth.external || !this.allowExoPlayer) {\n      return false;\n    }\n    const externalConfig = await getExternalConfig(this.hass!.auth.external);\n    return externalConfig && externalConfig.hasExoPlayer;\n  }\n\n  private async _startHls(): Promise<void> {\n    this._error = undefined;\n\n    const videoEl = this._videoEl;\n    const useExoPlayerPromise = this._getUseExoPlayer();\n    const masterPlaylistPromise = fetch(this.url);\n\n    const Hls: typeof HlsType = (await import(\"hls.js/dist/hls.light.min\"))\n      .default;\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    let hlsSupported = Hls.isSupported();\n\n    if (!hlsSupported) {\n      hlsSupported =\n        videoEl.canPlayType(\"application/vnd.apple.mpegurl\") !== \"\";\n    }\n\n    if (!hlsSupported) {\n      this._error = this.hass.localize(\n        \"ui.components.media-browser.video_not_supported\"\n      );\n      return;\n    }\n\n    const useExoPlayer = await useExoPlayerPromise;\n    const masterPlaylist = await (await masterPlaylistPromise).text();\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    // Parse playlist assuming it is a master playlist. Match group 1 is whether hevc, match group 2 is regular playlist url\n    // See https://tools.ietf.org/html/rfc8216 for HLS spec details\n    const playlistRegexp =\n      /#EXT-X-STREAM-INF:.*?(?:CODECS=\".*?(hev1|hvc1)?\\..*?\".*?)?(?:\\n|\\r\\n)(.+)/g;\n    const match = playlistRegexp.exec(masterPlaylist);\n    const matchTwice = playlistRegexp.exec(masterPlaylist);\n\n    // Get the regular playlist url from the input (master) playlist, falling back to the input playlist if necessary\n    // This avoids the player having to load and parse the master playlist again before loading the regular playlist\n    let playlist_url: string;\n    if (match !== null && matchTwice === null) {\n      // Only send the regular playlist url if we match exactly once\n      playlist_url = new URL(match[2], this.url).href;\n    } else {\n      playlist_url = this.url;\n    }\n\n    // If codec is HEVC and ExoPlayer is supported, use ExoPlayer.\n    if (useExoPlayer && match !== null && match[1] !== undefined) {\n      this._renderHLSExoPlayer(playlist_url);\n    } else if (Hls.isSupported()) {\n      this._renderHLSPolyfill(videoEl, Hls, playlist_url);\n    } else {\n      this._renderHLSNative(videoEl, playlist_url);\n    }\n  }\n\n  private async _renderHLSExoPlayer(url: string) {\n    this._exoPlayer = true;\n    window.addEventListener(\"resize\", this._resizeExoPlayer);\n    this.updateComplete.then(() => nextRender()).then(this._resizeExoPlayer);\n    this._videoEl.style.visibility = \"hidden\";\n    await this.hass!.auth.external!.sendMessage({\n      type: \"exoplayer/play_hls\",\n      payload: {\n        url: new URL(url, window.location.href).toString(),\n        muted: this.muted,\n      },\n    });\n  }\n\n  private _resizeExoPlayer = () => {\n    if (!this._videoEl) {\n      return;\n    }\n    const rect = this._videoEl.getBoundingClientRect();\n    this.hass!.auth.external!.fireMessage({\n      type: \"exoplayer/resize\",\n      payload: {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n      },\n    });\n  };\n\n  private async _renderHLSPolyfill(\n    videoEl: HTMLVideoElement,\n    Hls: typeof HlsType,\n    url: string\n  ) {\n    const hls = new Hls({\n      backBufferLength: 60,\n      fragLoadingTimeOut: 30000,\n      manifestLoadingTimeOut: 30000,\n      levelLoadingTimeOut: 30000,\n      maxLiveSyncPlaybackRate: 2,\n    });\n    this._hlsPolyfillInstance = hls;\n    hls.attachMedia(videoEl);\n    hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n      hls.loadSource(url);\n    });\n    hls.on(Hls.Events.ERROR, (_, data: any) => {\n      if (!data.fatal) {\n        return;\n      }\n      if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {\n        switch (data.details) {\n          case Hls.ErrorDetails.MANIFEST_LOAD_ERROR: {\n            let error = \"Error starting stream, see logs for details\";\n            if (\n              data.response !== undefined &&\n              data.response.code !== undefined\n            ) {\n              if (data.response.code >= 500) {\n                error += \" (Server failure)\";\n              } else if (data.response.code >= 400) {\n                error += \" (Stream never started)\";\n              } else {\n                error += \" (\" + data.response.code + \")\";\n              }\n            }\n            this._error = error;\n            return;\n          }\n          case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            this._error = \"Timeout while starting stream\";\n            return;\n          default:\n            this._error = \"Unknown stream network error (\" + data.details + \")\";\n            return;\n        }\n        this._error = \"Error with media stream contents (\" + data.details + \")\";\n      } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {\n        this._error = \"Error with media stream contents (\" + data.details + \")\";\n      } else {\n        this._error =\n          \"Unknown error with stream (\" + data.type + \", \" + data.details + \")\";\n      }\n    });\n  }\n\n  private async _renderHLSNative(videoEl: HTMLVideoElement, url: string) {\n    videoEl.src = url;\n    videoEl.addEventListener(\"loadedmetadata\", () => {\n      videoEl.play();\n    });\n  }\n\n  private _cleanUp() {\n    if (this._hlsPolyfillInstance) {\n      this._hlsPolyfillInstance.destroy();\n      this._hlsPolyfillInstance = undefined;\n    }\n    if (this._exoPlayer) {\n      window.removeEventListener(\"resize\", this._resizeExoPlayer);\n      this.hass!.auth.external!.fireMessage({ type: \"exoplayer/stop\" });\n      this._exoPlayer = false;\n    }\n    const videoEl = this._videoEl;\n    videoEl.removeAttribute(\"src\");\n    videoEl.load();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n\n      ha-alert {\n        display: block;\n        padding: 100px 16px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-hls-player\": HaHLSPlayer;\n  }\n}\n"],"names":[],"sourceRoot":""}