{"version":3,"file":"chunks/app_components_avatar_actorAvatar_tsx-app_components_tag_tsx-app_components_textOverflow_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/teams.tsx","webpack:///./app/components/avatar/actorAvatar.tsx","webpack:///./app/components/tag.tsx","webpack:///./app/components/textOverflow.tsx","webpack:///./app/styles/overflowEllipsisLeft.tsx","webpack:///./app/stores/memberListStore.tsx","webpack:///./app/utils/isActiveSuperuser.tsx","webpack:///./app/utils/teams.tsx","webpack:///./app/utils/useTeams.tsx"],"sourcesContent":["import {addErrorMessage, addSuccessMessage} from 'sentry/actionCreators/indicator';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport {tct} from 'sentry/locale';\nimport {Team} from 'sentry/types';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport {uniqueId} from 'sentry/utils/guid';\n\ntype CallbackOptions = {\n  success?: Function;\n  error?: Function;\n};\n\nconst doCallback = (\n  params: CallbackOptions = {},\n  name: keyof CallbackOptions,\n  ...args: any[]\n) => {\n  callIfFunction(params[name], ...args);\n};\n\n/**\n * Note these are both slugs\n */\ntype OrgSlug = {orgId: string};\ntype OrgAndTeamSlug = OrgSlug & {teamId: string};\n\ntype TeamData = {data: Team};\n\n/**\n * This is the actual internal id, not username or email\n */\ntype MemberId = {memberId: string};\n\n// Fetch teams for org\nexport function fetchTeams(api: Client, params: OrgSlug, options: CallbackOptions) {\n  TeamActions.fetchAll(params.orgId);\n  return api.request(`/teams/${params.orgId}/`, {\n    success: data => {\n      TeamActions.fetchAllSuccess(params.orgId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchAllError(params.orgId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\n// Fetch user teams for current org and place them in the team store\nexport async function fetchUserTeams(api: Client, params: OrgSlug) {\n  const teams = await api.requestPromise(`/organizations/${params.orgId}/user-teams/`);\n  TeamActions.loadUserTeams(teams);\n}\n\nexport function fetchTeamDetails(\n  api: Client,\n  params: OrgAndTeamSlug,\n  options?: CallbackOptions\n) {\n  TeamActions.fetchDetails(params.teamId);\n  return api.request(`/teams/${params.orgId}/${params.teamId}/`, {\n    success: data => {\n      TeamActions.fetchDetailsSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchDetailsError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function updateTeamSuccess(teamId: OrgAndTeamSlug['teamId'], data: Team) {\n  TeamActions.updateSuccess(teamId, data);\n}\n\nexport function updateTeam(\n  api: Client,\n  params: OrgAndTeamSlug & TeamData,\n  options: CallbackOptions\n) {\n  const endpoint = `/teams/${params.orgId}/${params.teamId}/`;\n  TeamActions.update(params.teamId, params.data);\n\n  return api.request(endpoint, {\n    method: 'PUT',\n    data: params.data,\n    success: data => {\n      updateTeamSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function joinTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId ?? 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'POST',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function leaveTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId || 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'DELETE',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function createTeam(api: Client, team: Pick<Team, 'slug'>, params: OrgSlug) {\n  TeamActions.createTeam(team);\n\n  return api\n    .requestPromise(`/organizations/${params.orgId}/teams/`, {\n      method: 'POST',\n      data: team,\n    })\n    .then(\n      data => {\n        TeamActions.createTeamSuccess(data);\n        addSuccessMessage(\n          tct('[team] has been added to the [organization] organization', {\n            team: `#${data.slug}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.createTeamError(team.slug, err);\n        addErrorMessage(\n          tct('Unable to create [team] in the [organization] organization', {\n            team: `#${team.slug}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n\nexport function removeTeam(api: Client, params: OrgAndTeamSlug) {\n  TeamActions.removeTeam(params.teamId);\n\n  return api\n    .requestPromise(`/teams/${params.orgId}/${params.teamId}/`, {\n      method: 'DELETE',\n    })\n    .then(\n      data => {\n        TeamActions.removeTeamSuccess(params.teamId, data);\n        addSuccessMessage(\n          tct('[team] has been removed from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.removeTeamError(params.teamId, err);\n        addErrorMessage(\n          tct('Unable to remove [team] from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n","import * as React from 'react';\nimport * as Sentry from '@sentry/react';\n\nimport TeamAvatar from 'sentry/components/avatar/teamAvatar';\nimport UserAvatar from 'sentry/components/avatar/userAvatar';\nimport LoadingIndicator from 'sentry/components/loadingIndicator';\nimport Tooltip from 'sentry/components/tooltip';\nimport MemberListStore from 'sentry/stores/memberListStore';\nimport {Actor} from 'sentry/types';\nimport Teams from 'sentry/utils/teams';\n\ntype DefaultProps = {\n  hasTooltip: boolean;\n  size: number;\n};\n\ntype Props = DefaultProps & {\n  actor: Actor;\n  default?: string;\n  title?: string;\n  gravatar?: boolean;\n  className?: string;\n  onClick?: () => void;\n  suggested?: boolean;\n  tooltip?: React.ReactNode;\n  tooltipOptions?: Omit<Tooltip['props'], 'children' | 'title'>;\n};\n\nclass ActorAvatar extends React.Component<Props> {\n  static defaultProps: DefaultProps = {\n    size: 24,\n    hasTooltip: true,\n  };\n\n  render() {\n    const {actor, ...props} = this.props;\n\n    if (actor.type === 'user') {\n      const user = actor.id ? MemberListStore.getById(actor.id) ?? actor : actor;\n      return <UserAvatar user={user} {...props} />;\n    }\n\n    if (actor.type === 'team') {\n      return (\n        <Teams ids={[actor.id]}>\n          {({initiallyLoaded, teams}) =>\n            initiallyLoaded ? (\n              <TeamAvatar team={teams[0]} {...props} />\n            ) : (\n              <LoadingIndicator mini />\n            )\n          }\n        </Teams>\n      );\n    }\n\n    Sentry.withScope(scope => {\n      scope.setExtra('actor', actor);\n      Sentry.captureException(new Error('Unknown avatar type'));\n    });\n\n    return null;\n  }\n}\n\nexport default ActorAvatar;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nimport Button from 'sentry/components/button';\nimport ExternalLink from 'sentry/components/links/externalLink';\nimport Link from 'sentry/components/links/link';\nimport Tooltip from 'sentry/components/tooltip';\nimport {IconClose, IconOpen} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport {defined} from 'sentry/utils';\nimport trackAdvancedAnalyticsEvent from 'sentry/utils/analytics/trackAdvancedAnalyticsEvent';\nimport theme, {Color, Theme} from 'sentry/utils/theme';\n\nconst TAG_HEIGHT = '20px';\n\ntype Props = React.HTMLAttributes<HTMLSpanElement> & {\n  /**\n   * Dictates color scheme of the tag.\n   */\n  type?: keyof Theme['tag'];\n  /**\n   * Icon on the left side.\n   */\n  icon?: React.ReactNode;\n  /**\n   * Text to show up on a hover.\n   */\n  tooltipText?: React.ComponentProps<typeof Tooltip>['title'];\n  /**\n   * Makes the tag clickable. Use for internal links handled by react router.\n   * If no icon is passed, it defaults to IconOpen (can be removed by passing icon={null})\n   */\n  to?: React.ComponentProps<typeof Link>['to'];\n  /**\n   * Triggered when the item is clicked\n   */\n  onClick?: (eventKey: any) => void;\n  /**\n   * Makes the tag clickable. Use for external links.\n   * If no icon is passed, it defaults to IconOpen (can be removed by passing icon={null})\n   */\n  href?: string;\n  /**\n   * Shows clickable IconClose on the right side.\n   */\n  onDismiss?: () => void;\n  /**\n   * Max width of the tag's text\n   */\n  textMaxWidth?: number;\n};\n\nfunction Tag({\n  type = 'default',\n  icon,\n  tooltipText,\n  to,\n  onClick,\n  href,\n  onDismiss,\n  children,\n  textMaxWidth = 150,\n  ...props\n}: Props) {\n  const iconsProps = {\n    size: '11px',\n    color: theme.tag[type].iconColor as Color,\n  };\n\n  const tag = (\n    <Tooltip title={tooltipText} containerDisplayMode=\"inline-flex\">\n      <Background type={type}>\n        {tagIcon()}\n\n        <Text type={type} maxWidth={textMaxWidth}>\n          {children}\n        </Text>\n\n        {defined(onDismiss) && (\n          <DismissButton\n            onClick={handleDismiss}\n            size=\"zero\"\n            priority=\"link\"\n            label={t('Dismiss')}\n          >\n            <IconClose isCircled {...iconsProps} />\n          </DismissButton>\n        )}\n      </Background>\n    </Tooltip>\n  );\n\n  function handleDismiss(event: React.MouseEvent) {\n    event.preventDefault();\n    onDismiss?.();\n  }\n\n  const trackClickEvent = () => {\n    trackAdvancedAnalyticsEvent('tag.clicked', {\n      is_clickable: defined(onClick) || defined(to) || defined(href),\n      organization: null,\n    });\n  };\n\n  function tagIcon() {\n    if (React.isValidElement(icon)) {\n      return <IconWrapper>{React.cloneElement(icon, {...iconsProps})}</IconWrapper>;\n    }\n\n    if ((defined(href) || defined(to)) && icon === undefined) {\n      return (\n        <IconWrapper>\n          <IconOpen {...iconsProps} />\n        </IconWrapper>\n      );\n    }\n\n    return null;\n  }\n\n  function tagWithParent() {\n    if (defined(href)) {\n      return <ExternalLink href={href}>{tag}</ExternalLink>;\n    }\n\n    if (defined(to) && defined(onClick)) {\n      return (\n        <Link to={to} onClick={onClick}>\n          {tag}\n        </Link>\n      );\n    }\n    if (defined(to)) {\n      return <Link to={to}>{tag}</Link>;\n    }\n\n    return tag;\n  }\n\n  return (\n    <TagWrapper {...props} onClick={trackClickEvent}>\n      {tagWithParent()}\n    </TagWrapper>\n  );\n}\n\nconst TagWrapper = styled('span')`\n  font-size: ${p => p.theme.fontSizeSmall};\n`;\n\nexport const Background = styled('div')<{type: keyof Theme['tag']}>`\n  display: inline-flex;\n  align-items: center;\n  height: ${TAG_HEIGHT};\n  border-radius: ${TAG_HEIGHT};\n  background-color: ${p => p.theme.tag[p.type].background};\n  border: solid 1px ${p => p.theme.tag[p.type].border};\n  padding: 0 ${space(1)};\n`;\n\nconst IconWrapper = styled('span')`\n  margin-right: ${space(0.5)};\n  display: inline-flex;\n`;\n\nconst Text = styled('span')<{maxWidth: number; type: keyof Theme['tag']}>`\n  color: ${p =>\n    ['black', 'white'].includes(p.type)\n      ? p.theme.tag[p.type].iconColor\n      : p.theme.textColor};\n  max-width: ${p => p.maxWidth}px;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  line-height: ${TAG_HEIGHT};\n`;\n\nconst DismissButton = styled(Button)`\n  margin-left: ${space(0.5)};\n  border: none;\n`;\n\nexport default Tag;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nimport overflowEllipsis from 'sentry/styles/overflowEllipsis';\nimport overflowEllipsisLeft from 'sentry/styles/overflowEllipsisLeft';\n\ntype Props = {\n  children: React.ReactNode;\n  isParagraph?: boolean;\n  ellipsisDirection?: 'left' | 'right';\n  ['data-test-id']?: string;\n  className?: string;\n};\n\nconst TextOverflow = styled(\n  ({isParagraph, className, children, ['data-test-id']: dataTestId}: Props) => {\n    const Component = isParagraph ? 'p' : 'div';\n    return (\n      <Component className={className} data-test-id={dataTestId}>\n        {children}\n      </Component>\n    );\n  }\n)`\n  ${p => (p.ellipsisDirection === 'right' ? overflowEllipsis : overflowEllipsisLeft)};\n  width: auto;\n  line-height: 1.2;\n`;\n\nTextOverflow.defaultProps = {\n  ellipsisDirection: 'right',\n  isParagraph: false,\n};\n\nexport default TextOverflow;\n","export default `\n  display: block;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  width: 100%;\n  direction: rtl;\n  text-align: left;\n`;\n","import Reflux from 'reflux';\n\nimport {User} from 'sentry/types';\n\ntype MemberListStoreInterface = {\n  state: User[];\n  loaded: boolean;\n  loadInitialData(items: User[]): void;\n  isLoaded(): boolean;\n  getById(id: string): User | undefined;\n  getByEmail(email: string): User | undefined;\n  getAll(): User[];\n};\n\nconst storeConfig: Reflux.StoreDefinition & MemberListStoreInterface = {\n  // listenables: MemberActions,\n\n  loaded: false,\n  state: [],\n\n  init() {\n    this.state = [];\n    this.loaded = false;\n  },\n\n  // TODO(dcramer): this should actually come from an action of some sorts\n  loadInitialData(items: User[]) {\n    this.state = items;\n    this.loaded = true;\n    this.trigger(this.state, 'initial');\n  },\n\n  isLoaded() {\n    return this.loaded;\n  },\n\n  getById(id) {\n    if (!this.state) {\n      return undefined;\n    }\n\n    id = '' + id;\n    for (let i = 0; i < this.state.length; i++) {\n      if (this.state[i].id === id) {\n        return this.state[i];\n      }\n    }\n    return undefined;\n  },\n\n  getByEmail(email) {\n    if (!this.state) {\n      return undefined;\n    }\n\n    email = email.toLowerCase();\n    for (let i = 0; i < this.state.length; i++) {\n      if (this.state[i].email.toLowerCase() === email) {\n        return this.state[i];\n      }\n    }\n    return undefined;\n  },\n\n  getAll() {\n    return this.state;\n  },\n};\n\nconst MemberListStore = Reflux.createStore(storeConfig) as Reflux.Store &\n  MemberListStoreInterface;\n\nexport default MemberListStore;\n","import Cookies from 'js-cookie';\n\nimport ConfigStore from 'sentry/stores/configStore';\n\nconst SUPERUSER_COOKIE_NAME = 'su';\n\n/**\n * Checking for just isSuperuser on a config object may not be enough as backend often checks for *active* superuser.\n * We therefore check both isSuperuser flag AND superuser session cookie.\n */\nexport function isActiveSuperuser() {\n  const {isSuperuser} = ConfigStore.get('user') || {};\n\n  if (isSuperuser) {\n    /**\n     * Superuser cookie cannot be checked for existence as it is HttpOnly.\n     * As a workaround, we try to change it to something else and if that fails we can assume that it's being present.\n     * There may be an edgecase where it's present and expired but for current usage it's not a big deal.\n     */\n    Cookies.set(SUPERUSER_COOKIE_NAME, 'test');\n\n    if (Cookies.get(SUPERUSER_COOKIE_NAME) === undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import {Fragment} from 'react';\n\nimport useTeams from 'sentry/utils/useTeams';\n\ntype RenderProps = ReturnType<typeof useTeams>;\n\ntype Props = Parameters<typeof useTeams>[0] & {\n  children: (props: RenderProps) => React.ReactNode;\n};\n\n/**\n * This is a utility component to leverage the useTeams hook to provide\n * a render props component which returns teams through a variety of inputs\n * such as a list of slugs or user teams.\n */\nfunction Teams({children, ...props}: Props) {\n  const renderProps = useTeams(props);\n\n  return <Fragment>{children(renderProps)}</Fragment>;\n}\n\nexport default Teams;\n","import {useEffect, useRef, useState} from 'react';\nimport uniqBy from 'lodash/uniqBy';\n\nimport {fetchUserTeams} from 'sentry/actionCreators/teams';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport OrganizationStore from 'sentry/stores/organizationStore';\nimport TeamStore from 'sentry/stores/teamStore';\nimport {useLegacyStore} from 'sentry/stores/useLegacyStore';\nimport {Team} from 'sentry/types';\nimport {isActiveSuperuser} from 'sentry/utils/isActiveSuperuser';\nimport parseLinkHeader from 'sentry/utils/parseLinkHeader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\n\ntype State = {\n  /**\n   * Reflects whether or not the initial fetch for the requested teams was\n   * fulfilled\n   */\n  initiallyLoaded: boolean;\n  /**\n   * This is state for when fetching data from API\n   */\n  fetching: boolean;\n  /**\n   * The error that occurred if fetching failed\n   */\n  fetchError: null | RequestError;\n  /**\n   * Indicates that Team results (from API) are paginated and there are more\n   * Teams that are not in the initial response.\n   */\n  hasMore: null | boolean;\n  /**\n   * The last query we searched. Used to validate the cursor\n   */\n  lastSearch: null | string;\n  /**\n   * Pagination\n   */\n  nextCursor?: null | string;\n};\n\nexport type Result = {\n  /**\n   * The loaded teams list\n   */\n  teams: Team[];\n  /**\n   * This is an action provided to consumers for them to update the current\n   * teams result set using a simple search query.\n   *\n   * Will always add new options into the store.\n   */\n  onSearch: (searchTerm: string) => Promise<void>;\n  /**\n   * This is an action provided to consumers for them to request more teams\n   * to be loaded. Additional teams will be fetched and loaded into the store.\n   */\n  loadMore: (searchTerm?: string) => Promise<void>;\n} & Pick<State, 'fetching' | 'hasMore' | 'fetchError' | 'initiallyLoaded'>;\n\ntype Options = {\n  /**\n   * Number of teams to return when not using `props.slugs`\n   */\n  limit?: number;\n  /**\n   * When provided, fetches specified teams by slug if necessary and only provides those teams.\n   */\n  slugs?: string[];\n  /**\n   * When provided, fetches specified teams by id if necessary and only provides those teams.\n   */\n  ids?: string[];\n  /**\n   * When true, fetches user's teams if necessary and only provides user's\n   * teams (isMember = true).\n   */\n  provideUserTeams?: boolean;\n};\n\ntype FetchTeamOptions = {\n  slugs?: string[];\n  ids?: string[];\n  limit?: Options['limit'];\n  cursor?: State['nextCursor'];\n  search?: State['lastSearch'];\n  lastSearch?: State['lastSearch'];\n};\n\n/**\n * Helper function to actually load teams\n */\nasync function fetchTeams(\n  api: Client,\n  orgId: string,\n  {slugs, ids, search, limit, lastSearch, cursor}: FetchTeamOptions = {}\n) {\n  const query: {\n    query?: string;\n    cursor?: typeof cursor;\n    per_page?: number;\n  } = {};\n\n  if (slugs !== undefined && slugs.length > 0) {\n    query.query = slugs.map(slug => `slug:${slug}`).join(' ');\n  }\n\n  if (ids !== undefined && ids.length > 0) {\n    query.query = ids.map(id => `id:${id}`).join(' ');\n  }\n\n  if (search) {\n    query.query = `${query.query ?? ''} ${search}`.trim();\n  }\n\n  const isSameSearch = lastSearch === search || (!lastSearch && !search);\n\n  if (isSameSearch && cursor) {\n    query.cursor = cursor;\n  }\n\n  if (limit !== undefined) {\n    query.per_page = limit;\n  }\n\n  let hasMore: null | boolean = false;\n  let nextCursor: null | string = null;\n  const [data, , resp] = await api.requestPromise(`/organizations/${orgId}/teams/`, {\n    includeAllArgs: true,\n    query,\n  });\n\n  const pageLinks = resp?.getResponseHeader('Link');\n  if (pageLinks) {\n    const paginationObject = parseLinkHeader(pageLinks);\n    hasMore = paginationObject?.next?.results;\n    nextCursor = paginationObject?.next?.cursor;\n  }\n\n  return {results: data, hasMore, nextCursor};\n}\n\n// TODO: Paging for items which have already exist in the store is not\n// correctly implemented.\n\n/**\n * Provides teams from the TeamStore\n *\n * This hook also provides a way to select specific slugs to ensure they are\n * loaded, as well as search (type-ahead) for more slugs that may not be in the\n * TeamsStore.\n *\n * NOTE: It is NOT guaranteed that all teams for an organization will be\n * loaded, so you should use this hook with the intention of providing specific\n * slugs, or loading more through search.\n *\n */\nfunction useTeams({limit, slugs, ids, provideUserTeams}: Options = {}) {\n  const api = useApi();\n  const {organization} = useLegacyStore(OrganizationStore);\n  const store = useLegacyStore(TeamStore);\n\n  const orgId = organization?.slug;\n\n  const storeSlugs = new Set(store.teams.map(t => t.slug));\n  const slugsToLoad = slugs?.filter(slug => !storeSlugs.has(slug)) ?? [];\n  const storeIds = new Set(store.teams.map(t => t.id));\n  const idsToLoad = ids?.filter(id => !storeIds.has(id)) ?? [];\n  const shouldLoadSlugs = slugsToLoad.length > 0;\n  const shouldLoadIds = idsToLoad.length > 0;\n  const shouldLoadTeams = provideUserTeams && !store.loadedUserTeams;\n\n  // If we don't need to make a request either for slugs or user teams, set\n  // initiallyLoaded to true\n  const initiallyLoaded = !shouldLoadSlugs && !shouldLoadTeams && !shouldLoadIds;\n\n  const [state, setState] = useState<State>({\n    initiallyLoaded,\n    fetching: false,\n    hasMore: store.hasMore,\n    lastSearch: null,\n    nextCursor: store.cursor,\n    fetchError: null,\n  });\n\n  const slugOrIdRef = useRef<Set<string> | null>(null);\n\n  // Only initialize slugOrIdRef.current once and modify it when we receive new\n  // slugs or ids determined through set equality\n  if (slugs !== undefined || ids !== undefined) {\n    const slugsOrIds = (slugs || ids) ?? [];\n    if (slugOrIdRef.current === null) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n\n    if (\n      slugsOrIds.length !== slugOrIdRef.current.size ||\n      slugsOrIds.some(slugOrId => !slugOrIdRef.current?.has(slugOrId))\n    ) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n  }\n\n  async function loadUserTeams() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      await fetchUserTeams(api, {orgId});\n\n      setState({...state, fetching: false, initiallyLoaded: true});\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function loadTeamsBySlugOrId() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        slugs: slugsToLoad,\n        ids: idsToLoad,\n        limit,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n      TeamActions.loadTeams(fetchedTeams);\n\n      setState({\n        ...state,\n        hasMore,\n        fetching: false,\n        initiallyLoaded: true,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function handleSearch(search: string) {\n    if (search === '') {\n      // Reset pagination state to match store if doing an empty search\n      if (state.hasMore !== store.hasMore || state.nextCursor !== store.cursor) {\n        setState({\n          ...state,\n          lastSearch: search,\n          hasMore: store.hasMore,\n          nextCursor: store.cursor,\n        });\n      }\n\n      return;\n    }\n    handleFetchAdditionalTeams(search);\n  }\n\n  async function handleFetchAdditionalTeams(search?: string) {\n    const {lastSearch} = state;\n    // Use the store cursor if there is no search keyword provided\n    const cursor = search ? state.nextCursor : store.cursor;\n\n    if (orgId === undefined) {\n      // eslint-disable-next-line no-console\n      console.error('Cannot fetch teams without an organization in context');\n      return;\n    }\n\n    setState({...state, fetching: true});\n\n    try {\n      api.clear();\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        search,\n        limit,\n        lastSearch,\n        cursor,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n\n      if (search) {\n        // Only update the store if we have more items\n        if (fetchedTeams.length > store.teams.length) {\n          TeamActions.loadTeams(fetchedTeams);\n        }\n      } else {\n        // If we fetched a page of teams without a search query, add cursor data to the store\n        TeamActions.loadTeams(fetchedTeams, hasMore, nextCursor);\n      }\n\n      setState({\n        ...state,\n        hasMore: hasMore && store.hasMore,\n        fetching: false,\n        lastSearch: search ?? null,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, fetchError: err});\n    }\n  }\n\n  useEffect(() => {\n    // Load specified team slugs\n    if (shouldLoadSlugs || shouldLoadIds) {\n      loadTeamsBySlugOrId();\n      return;\n    }\n\n    // Load user teams\n    if (shouldLoadTeams) {\n      loadUserTeams();\n    }\n  }, [slugOrIdRef.current, provideUserTeams]);\n\n  const isSuperuser = isActiveSuperuser();\n\n  const filteredTeams = slugs\n    ? store.teams.filter(t => slugs.includes(t.slug))\n    : ids\n    ? store.teams.filter(t => ids.includes(t.id))\n    : provideUserTeams && !isSuperuser\n    ? store.teams.filter(t => t.isMember)\n    : store.teams;\n\n  const result: Result = {\n    teams: filteredTeams,\n    fetching: state.fetching || store.loading,\n    initiallyLoaded: state.initiallyLoaded,\n    fetchError: state.fetchError,\n    hasMore: state.hasMore ?? store.hasMore,\n    onSearch: handleSearch,\n    loadMore: handleFetchAdditionalTeams,\n  };\n\n  return result;\n}\n\nexport default useTeams;\n"],"names":["doCallback","params","name","args","callIfFunction","async","fetchUserTeams","api","teams","requestPromise","orgId","TeamActions","updateTeamSuccess","teamId","data","updateTeam","options","endpoint","request","method","success","error","joinTeam","memberId","id","uniqueId","leaveTeam","createTeam","team","then","addSuccessMessage","tct","slug","organization","err","addErrorMessage","removeTeam","ActorAvatar","React","render","actor","props","this","type","user","MemberListStore","ids","initiallyLoaded","mini","Sentry","scope","setExtra","Error","size","hasTooltip","TAG_HEIGHT","Tag","icon","tooltipText","to","onClick","href","onDismiss","children","textMaxWidth","iconsProps","color","theme","iconColor","tag","title","containerDisplayMode","Background","IconWrapper","defined","undefined","Text","maxWidth","DismissButton","event","preventDefault","priority","label","t","isCircled","TagWrapper","trackAdvancedAnalyticsEvent","is_clickable","p","fontSizeSmall","background","border","space","includes","textColor","Button","TextOverflow","isParagraph","className","dataTestId","Component","ellipsisDirection","overflowEllipsis","defaultProps","storeConfig","loaded","state","init","loadInitialData","items","trigger","isLoaded","getById","i","length","getByEmail","email","toLowerCase","getAll","Reflux","isActiveSuperuser","isSuperuser","ConfigStore","Cookies","Teams","renderProps","useTeams","Fragment","fetchTeams","slugs","search","limit","lastSearch","cursor","query","map","join","trim","per_page","hasMore","nextCursor","resp","includeAllArgs","pageLinks","getResponseHeader","paginationObject","parseLinkHeader","next","results","provideUserTeams","useApi","useLegacyStore","OrganizationStore","store","TeamStore","storeSlugs","Set","slugsToLoad","filter","has","storeIds","idsToLoad","shouldLoadSlugs","shouldLoadIds","shouldLoadTeams","loadedUserTeams","setState","useState","fetching","fetchError","slugOrIdRef","useRef","slugsOrIds","current","some","slugOrId","handleFetchAdditionalTeams","clear","fetchedTeams","uniqBy","console","useEffect","loadTeamsBySlugOrId","loadUserTeams","isMember","loading","onSearch","loadMore"],"sourceRoot":""}