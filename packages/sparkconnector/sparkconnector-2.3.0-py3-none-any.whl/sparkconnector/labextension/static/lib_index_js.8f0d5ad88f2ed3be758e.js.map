{"version":3,"file":"lib_index_js.8f0d5ad88f2ed3be758e.js","mappings":";;;;;;;;;;;;;;;AAAwC;AACxC,4BAA4B,iDAAU,OAAO,4fAA4D;AAClG;AACP,YAAY,0DAAmB,CAAC,2CAAQ,IAAI,UAAU,0DAAmB,0BAA0B;AACnG,QAAQ,0DAAmB;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLsE;AACd;AACU;AACd;AAC1B;AACM;AACkC;AACb;AACJ;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAS,EAAE,kEAAgB,EAAE,oEAAe;AAC3D,eAAe,+DAAa;AAC5B;AACA;AACA;AACA,iEAAe,MAAM,EAAC;AACtB;AACA;AACA;AACA;AACA,6BAA6B,8DAAmB;AAChD,IAAI,yDAAqB;AACzB,wBAAwB,oEAAkB,CAAC,0DAAmB,CAAC,2EAAuB;AACtF;AACA;AACA,iCAAiC,8DAAO;AACxC;AACA,gBAAgB,8DAAS;AACzB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA,YAAY,oDAAgB;AAC5B;AACA;AACA;AACA,gBAAgB,oDAAgB;AAChC;AACA;AACA,gBAAgB,oDAAgB;AAChC;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrDmC;AACkB;AACrB;AAChC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mDAAmD,sEAAoB;AACvE;AACA,SAAS;AACT,2CAA2C,sEAAoB;AAC/D;AACA,SAAS;AACT,QAAQ,uEAAmC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,iDAAW;AACvB,gBAAgB,mDAAe;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAe;AAC5B;AACA,YAAY,6DAAyB;AACrC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAW;AAC/B,wBAAwB,mDAAe;AACvC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,2DAAuB;AACvC;AACA;AACA,gBAAgB,2DAAuB;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAW;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAuB;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,mDAAe;AACvC;AACA;AACA,wBAAwB,mDAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAe;AACnC;AACA;AACA;AACA,oBAAoB,mDAAe;AACnC;AACA;AACA;AACA;AACA,oBAAoB,mDAAe;AACnC;AACA;AACA;AACA,oBAAoB,mDAAe;AACnC,oBAAoB,mDAAe;AACnC;AACA;AACA;AACA,oBAAoB,mDAAe;AACnC,oBAAoB,mDAAe;AACnC;AACA;AACA;AACA,oBAAoB,6DAAyB;AAC7C;AACA;AACA;AACA,oBAAoB,oDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxQ0C;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,wDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,wDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;ACtSA,iEAAe,g2DAAg2D","sources":["webpack://@swan-cern/sparkconnector/./lib/components/lazy-panel.js","webpack://@swan-cern/sparkconnector/./lib/index.js","webpack://@swan-cern/sparkconnector/./lib/labconnector.js","webpack://@swan-cern/sparkconnector/./lib/store.js","webpack://@swan-cern/sparkconnector/./style/apachespark.svg"],"sourcesContent":["import React, { Suspense } from 'react';\nconst SparkConnectorPanel = React.lazy(() => import(/* webpackChunkName: \"sparkconnectorui\" */ './panel'));\nexport const LazySparkConnectorPanel = () => {\n    return (React.createElement(Suspense, { fallback: React.createElement(\"div\", null, \"loading\") },\n        React.createElement(SparkConnectorPanel, null)));\n};\n","import { ILabShell, ILayoutRestorer, } from '@jupyterlab/application';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ReactWidget, IThemeManager } from '@jupyterlab/apputils';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport React from 'react';\nimport { store } from './store';\nimport { LazySparkConnectorPanel } from './components/lazy-panel';\nimport { JupyterLabConnector } from './labconnector';\nimport SparkIcon from '../style/apachespark.svg';\n/**\n * Initialization data for the sparkconnector extension.\n */\nconst plugin = {\n    id: 'sparkconnector',\n    requires: [ILabShell, INotebookTracker, ILayoutRestorer],\n    optional: [IThemeManager],\n    activate: activate,\n    autoStart: true,\n};\nexport default plugin;\n/**\n * Activate the running plugin.\n */\nfunction activate(app, labShell, notebooks, restorer, themeManager) {\n    const appConnector = new JupyterLabConnector(app, notebooks);\n    store.setAppConnector(appConnector);\n    const panelWidget = ReactWidget.create(React.createElement(LazySparkConnectorPanel));\n    panelWidget.id = 'spark-connector';\n    panelWidget.title.caption = 'Apache Spark';\n    panelWidget.title.icon = new LabIcon({\n        name: 'sparkconnector:sparkicon',\n        svgstr: SparkIcon,\n    });\n    labShell.add(panelWidget, 'right', {\n        rank: 700,\n    });\n    if (themeManager) {\n        if (themeManager.theme && themeManager.isLight(themeManager.theme)) {\n            store.colorTheme = 'light';\n        }\n        else {\n            store.colorTheme = 'dark';\n        }\n        themeManager.themeChanged.connect((_, args) => {\n            if (themeManager.isLight(args.newValue)) {\n                store.colorTheme = 'light';\n            }\n            else {\n                store.colorTheme = 'dark';\n            }\n        });\n    }\n    console.log('SparkConnector: Jupyter Lab extension is activated!');\n}\n","import { runInAction } from 'mobx';\nimport { ConfigSection } from '@jupyterlab/services';\nimport { store } from './store';\nconst SPARKCONNECTOR_COMM_TARGET = 'SparkConnector';\n/*\n  Jupyterlab specific integration.\n*/\nexport class JupyterLabConnector {\n    constructor(labApp, notebookTracker) {\n        Object.defineProperty(this, \"labApp\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: labApp\n        });\n        Object.defineProperty(this, \"notebookTracker\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: notebookTracker\n        });\n        /*\n          Mapping between notebookPanel Ids to Comm objects\n          opened in the kernel for that object.\n        */\n        Object.defineProperty(this, \"comms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        this.initConfigurationFromServer();\n        this.initStateHandling();\n    }\n    async initConfigurationFromServer() {\n        const availableOptionConfigSection = await ConfigSection.create({\n            name: 'sparkconnector_spark_options',\n        });\n        const bundlesConfigSection = await ConfigSection.create({\n            name: 'sparkconnector_bundles',\n        });\n        store.updateConfigurationFromServer(availableOptionConfigSection.data, bundlesConfigSection.data);\n    }\n    getNotebookPanel(notebookPanelId) {\n        const notebookPanel = this.notebookTracker.find((nb) => nb.id === notebookPanelId);\n        if (!notebookPanel) {\n            throw new Error('SparkConnector: Notebook Panel does not exist');\n        }\n        return notebookPanel;\n    }\n    createComm(notebookPanel) {\n        var _a;\n        const kernel = (_a = notebookPanel.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel;\n        if (!kernel) {\n            throw new Error('SparkConnector: Trying to create comm when kernel/session is null');\n        }\n        console.log('SparkConnector: CREATE COMM for ', notebookPanel.title.label, kernel.id);\n        const comm = kernel.createComm(SPARKCONNECTOR_COMM_TARGET);\n        this.comms.set(notebookPanel.id, comm);\n        comm.open({\n            type: 'action',\n            action: 'sparkconn-action-open',\n        });\n        comm.onClose = () => {\n            this.comms.delete(notebookPanel.id);\n            runInAction(() => {\n                store.notebooks[notebookPanel.id].status = 'notattached';\n            });\n            console.log('SparkConnector: Comm closed:', notebookPanel.title.label);\n        };\n        comm.onMsg = (msg) => {\n            this.handleCommMessage(msg, notebookPanel);\n        };\n    }\n    async trackNotebook(notebookPanel) {\n        if (!store.notebooks[notebookPanel.id]) {\n            // If we don't already have a stored state for this notebook:\n            store.createNotebookState(notebookPanel.id, {\n                title: notebookPanel.title.label,\n            });\n        }\n        // Ensure the state of the jupyterlab kernel/session object is synced with API\n        await notebookPanel.sessionContext.ready;\n        // Connect to kernel on first page load\n        if (!this.comms.has(notebookPanel.id)) {\n            try {\n                this.createComm(notebookPanel);\n            }\n            catch (e) {\n                console.error('SparkConnector: Error creating comm');\n            }\n        }\n        // Connect to kernel when a restarting etc.\n        // The statusChanged.connect is no-op if already connected.\n        notebookPanel.sessionContext.statusChanged.connect((_, status) => {\n            switch (status) {\n                case 'restarting':\n                case 'terminating':\n                case 'autorestarting':\n                case 'dead':\n                case 'unknown':\n                    this.comms.delete(notebookPanel.id);\n                    runInAction(() => {\n                        store.notebooks[notebookPanel.id].status = 'notattached';\n                    });\n                    break;\n                case 'starting':\n                    if (!this.comms.has(notebookPanel.id)) {\n                        try {\n                            this.createComm(notebookPanel);\n                        }\n                        catch (e) {\n                            console.error('SparkConnector: Error creating comm');\n                        }\n                    }\n                    break;\n            }\n        }, this);\n    }\n    initStateHandling() {\n        this.notebookTracker.widgetAdded.connect((_, notebookPanel) => {\n            this.trackNotebook(notebookPanel);\n        });\n        this.notebookTracker.currentChanged.connect((_, notebookPanel) => {\n            if (!notebookPanel) {\n                // There is no notebook panel selected\n                store.setActiveNotebook(null);\n            }\n            else {\n                store.setActiveNotebook(notebookPanel.id);\n            }\n        });\n    }\n    /*\n      Handle messages from the Kernel extension.\n    */\n    handleCommMessage(message, notebookPanel) {\n        runInAction(() => {\n            const data = message.content.data;\n            switch (data.msgtype) {\n                case 'sparkconn-action-open': {\n                    const page = message.content.data.page;\n                    const savedConfig = this.getSavedConfigFromNotebookMetadata(notebookPanel);\n                    store.setNotebookConfig(notebookPanel.id, {\n                        maxMemory: data.maxmemory,\n                        sparkVersion: data.sparkversion,\n                        clusterName: data.cluster,\n                        savedConfig,\n                    });\n                    if (page === 'sparkconn-config') {\n                        store.notebooks[notebookPanel.id].status = 'configuring';\n                    }\n                    else if (page === 'sparkconn-auth') {\n                        store.notebooks[notebookPanel.id].status = 'auth';\n                    }\n                    else if (page === 'sparkconn-connected') {\n                        // The kernel sends this page when a comm is opened, but the\n                        // user is already connected. It subsequently also sends a msgtype: sparkconn-connected,\n                        // so we don't do anything here\n                    }\n                    else {\n                        console.log('SparkConnector: Unknown page from server');\n                    }\n                    break;\n                }\n                case 'sparkconn-connected': {\n                    store.notebooks[notebookPanel.id].connectionResources = {\n                        sparkHistoryServerUrl: data.config.sparkhistoryserver,\n                        sparkMetricsUrl: data.config.sparkmetrics,\n                    };\n                    store.notebooks[notebookPanel.id].status = 'connected';\n                    break;\n                }\n                case 'sparkconn-config': {\n                    // Sent by kernel on successful authentication\n                    store.notebooks[notebookPanel.id].status = 'configuring';\n                    break;\n                }\n                case 'sparkconn-auth': {\n                    store.notebooks[notebookPanel.id].status = 'auth';\n                    store.notebooks[notebookPanel.id].authError = data.error;\n                    break;\n                }\n                case 'sparkconn-connect-error': {\n                    store.notebooks[notebookPanel.id].errorMessage = data.error;\n                    store.notebooks[notebookPanel.id].status = 'error';\n                    break;\n                }\n                case 'sparkconn-action-follow-log': {\n                    store.appendConnectionLog(notebookPanel.id, data.msg);\n                    break;\n                }\n                case 'sparkconn-action-tail-log': {\n                    store.updateLogs(notebookPanel.id, data.msg);\n                    break;\n                }\n                default:\n                    console.error('SparkConnector: Received an unknown msgtype from kernel:', message);\n                    break;\n            }\n        });\n    }\n    onClickAuthenticate(notebookPanelId, password) {\n        const comm = this.comms.get(notebookPanelId);\n        if (comm) {\n            comm.send({\n                action: 'sparkconn-action-auth',\n                password,\n            });\n        }\n    }\n    onClickConnect(notebookPanelId, options) {\n        const comm = this.comms.get(notebookPanelId);\n        if (comm) {\n            comm.send({\n                action: 'sparkconn-action-connect',\n                options,\n            });\n        }\n    }\n    async promptUserForKernelRestart(notebookPanelId) {\n        return this.labApp.commands.execute('notebook:restart-kernel');\n    }\n    async onClickRestart(notebookPanelId) {\n        // Restart the kernel, because SparkContexts are cached,\n        // we need to restart to do a clean retry again\n        const isRestarted = await this.promptUserForKernelRestart(notebookPanelId);\n        if (isRestarted) {\n            const comm = this.comms.get(notebookPanelId);\n            if (comm) {\n                comm.send({\n                    action: 'sparkconn-action-disconnect',\n                });\n            }\n        }\n    }\n    onRefreshLogs(notebookPanelId) {\n        const comm = this.comms.get(notebookPanelId);\n        if (comm) {\n            comm.send({\n                action: 'sparkconn-action-getlogs',\n            });\n        }\n    }\n    getSavedConfigFromNotebookMetadata(notebookPanel) {\n        var _a;\n        let currentConfig;\n        if ((_a = notebookPanel.model) === null || _a === void 0 ? void 0 : _a.metadata.has('sparkconnect')) {\n            currentConfig = notebookPanel.model.metadata.get('sparkconnect');\n        }\n        else {\n            currentConfig = {\n                bundled_options: [],\n                list_of_options: [],\n            };\n        }\n        // TODO silently remove any bundles that are not in the current set.\n        return currentConfig;\n    }\n    saveCurrentConfigToNotebookMetadata(notebookPanelId, config) {\n        var _a;\n        const notebookPanel = this.getNotebookPanel(notebookPanelId);\n        (_a = notebookPanel.model) === null || _a === void 0 ? void 0 : _a.metadata.set('sparkconnect', config);\n    }\n}\n","import { makeAutoObservable } from 'mobx';\nlet uniqueId = 0;\n/*\n  An observable MobX store.\n\n  React components wrapped with observer() are automatically re-rendered\n  when the store data is changed.\n\n  All updates to the store must either be methods on this class or\n  be wrapped in action(). See MobX documentation for details.\n*/\nclass SparkConnectorStore {\n    constructor() {\n        Object.defineProperty(this, \"colorTheme\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'light'\n        });\n        Object.defineProperty(this, \"notebooks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"allAvailableBundles\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"availableOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"currentNotebookPanelId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"appConnector\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        makeAutoObservable(this);\n    }\n    setAppConnector(connector) {\n        this.appConnector = connector;\n    }\n    updateConfigurationFromServer(sparkOptionsData, bundleData) {\n        this.allAvailableBundles = bundleData.bundled_options || {};\n        const sparkOptions = (sparkOptionsData === null || sparkOptionsData === void 0 ? void 0 : sparkOptionsData.spark_options) || [];\n        // Sort the options alphabetically based on category\n        // for auto-complete to work\n        sparkOptions.sort((a, b) => {\n            return a.data.category.localeCompare(b.data.category);\n        });\n        this.availableOptions = sparkOptions;\n    }\n    /*\n      Computed/Derived values from the state\n    */\n    get currentNotebook() {\n        return this.notebooks[this.currentNotebookPanelId];\n    }\n    /*\n      Actions that modify the state\n    */\n    createNotebookState(notebookPanelId, options) {\n        const notebookState = new NotebookStateStore();\n        notebookState.title = options.title;\n        notebookState.status = 'notattached';\n        this.notebooks[notebookPanelId] = notebookState;\n        this.currentNotebookPanelId = notebookPanelId;\n    }\n    setActiveNotebook(notebookPanelId) {\n        this.currentNotebookPanelId = notebookPanelId;\n    }\n    deleteNotebookState(notebookPanelId) {\n        delete this.notebooks[notebookPanelId];\n        if ((this.currentNotebookPanelId = notebookPanelId)) {\n            this.currentNotebookPanelId = null;\n        }\n    }\n    setNotebookConfig(notebookPanelId, options) {\n        var _a, _b, _c;\n        this.notebooks[notebookPanelId].clusterName = options.clusterName;\n        this.notebooks[notebookPanelId].sparkVersion = options.sparkVersion;\n        this.notebooks[notebookPanelId].maxMemory = options.maxMemory;\n        this.notebooks[notebookPanelId].selectedConfigurations = [];\n        this.notebooks[notebookPanelId].selectedBundles = [];\n        (_a = options === null || options === void 0 ? void 0 : options.savedConfig) === null || _a === void 0 ? void 0 : _a.bundled_options.forEach((bundleName) => {\n            // Ignore any bundles not in our current configuration and not available for the selected cluster/session\n            if (this.allAvailableBundles[bundleName] &&\n                this.notebooks[notebookPanelId].filteredAvailableBundles[bundleName]) {\n                this.notebooks[notebookPanelId].selectedBundles.push(bundleName);\n            }\n        });\n        (_c = (_b = options === null || options === void 0 ? void 0 : options.savedConfig) === null || _b === void 0 ? void 0 : _b.list_of_options) === null || _c === void 0 ? void 0 : _c.forEach((config) => {\n            this.notebooks[notebookPanelId].selectedConfigurations.push({\n                id: `${++uniqueId}`,\n                name: config.name,\n                value: config.value,\n                isEnabled: config.isEnabled !== undefined ? config.isEnabled : true,\n            });\n        });\n    }\n    appendConnectionLog(notebookPanelId, message) {\n        this.notebooks[notebookPanelId].logs.push(message);\n    }\n    updateLogs(notebookPanelId, logs) {\n        this.notebooks[notebookPanelId].logs = logs;\n    }\n    onClickConnect() {\n        var _a, _b;\n        if (!this.currentNotebookPanelId) {\n            throw Error('SparkConnector: Inconsistent state. Attempting to connect with no active notebook.');\n        }\n        console.log('SparkConnector: Connecting to Spark', this.currentNotebook.optionsToSendToKernel);\n        store.currentNotebook.status = 'connecting';\n        store.currentNotebook.logs = ['Waiting for spark context to start'];\n        const notebookMetadata = {\n            bundled_options: store.currentNotebook.selectedBundles,\n            list_of_options: store.currentNotebook.selectedConfigurations.map((c) => ({\n                name: c.name,\n                value: c.value,\n            })),\n        };\n        (_a = this.appConnector) === null || _a === void 0 ? void 0 : _a.saveCurrentConfigToNotebookMetadata(this.currentNotebookPanelId, notebookMetadata);\n        (_b = this.appConnector) === null || _b === void 0 ? void 0 : _b.onClickConnect(this.currentNotebookPanelId, this.currentNotebook.optionsToSendToKernel);\n    }\n    onClickAuthenticate(password) {\n        var _a;\n        this.currentNotebook.status = 'loading';\n        store.currentNotebook.authError = undefined;\n        (_a = this.appConnector) === null || _a === void 0 ? void 0 : _a.onClickAuthenticate(this.currentNotebookPanelId, password);\n    }\n    onClickRestart() {\n        var _a;\n        (_a = this.appConnector) === null || _a === void 0 ? void 0 : _a.onClickRestart(store.currentNotebookPanelId);\n    }\n    onRefreshLogs() {\n        var _a;\n        (_a = this.appConnector) === null || _a === void 0 ? void 0 : _a.onRefreshLogs(this.currentNotebookPanelId);\n    }\n}\nclass NotebookStateStore {\n    constructor() {\n        Object.defineProperty(this, \"title\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxMemory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sparkVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"clusterName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"authError\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'configuring'\n        });\n        Object.defineProperty(this, \"selectedConfigurations\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"selectedBundles\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"errorMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connectionResources\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"logs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        makeAutoObservable(this);\n    }\n    get filteredAvailableBundles() {\n        const filteredBundles = {};\n        Object.keys(store.allAvailableBundles).forEach((bundleName) => {\n            const bundle = store.allAvailableBundles[bundleName];\n            const isNotEnabledForCluster = bundle.cluster_filter &&\n                bundle.cluster_filter.length !== 0 &&\n                !bundle.cluster_filter.includes(this.clusterName);\n            const isNotEnabledForSparkVersion = bundle.spark_version_filter &&\n                bundle.spark_version_filter.length !== 0 &&\n                !bundle.spark_version_filter.includes(this.sparkVersion);\n            if (!(isNotEnabledForCluster || isNotEnabledForSparkVersion)) {\n                filteredBundles[bundleName] = bundle;\n            }\n        });\n        return filteredBundles;\n    }\n    get optionsToSendToKernel() {\n        const options = {};\n        this.selectedConfigurations.forEach((configuration) => {\n            if (configuration.isEnabled) {\n                options[configuration.name] = configuration.value;\n            }\n        });\n        // here the bundles are merged with the user configurations:\n        // - if key in bundle does not exist already, it is created\n        // - if it exists already, we check the \"concatenate\" value:\n        //   - if it exists, we use it to concatenate to the existing conf,\n        //   - otherwise we don't add it: the choices of the user have higher priority\n        this.selectedBundles.forEach((bundleName) => {\n            this.filteredAvailableBundles[bundleName].options.forEach((bundleOption) => {\n                if (bundleOption['name'] in options) {\n                    if (bundleOption['concatenate'] &&\n                        bundleOption['concatenate'] !== '') {\n                        options[bundleOption['name']] =\n                            options[bundleOption['name']] +\n                                bundleOption['concatenate'] +\n                                bundleOption['value'];\n                    } //else we don't add it\n                }\n                else {\n                    //we create the new option\n                    options[bundleOption['name']] = bundleOption['value'];\n                }\n            });\n        });\n        return options;\n    }\n    addConfiguration(name, value) {\n        this.selectedConfigurations.push({\n            id: `${++uniqueId}`,\n            name,\n            value,\n            isEnabled: true,\n        });\n    }\n    removeConfiguration(id) {\n        const index = this.selectedConfigurations.findIndex((c) => c.id === id);\n        if (index > -1) {\n            this.selectedConfigurations.splice(index, 1);\n        }\n    }\n    addBundle(bundleName) {\n        this.selectedBundles.push(bundleName);\n    }\n    removeBundle(bundleName) {\n        const index = this.selectedBundles.indexOf(bundleName);\n        if (index > -1) {\n            this.selectedBundles.splice(index, 1);\n        }\n    }\n}\nexport const store = new SparkConnectorStore();\n// For debugging\nwindow.sparkConnectorStore = store;\n","export default \"<svg fill=\\\"#616161\\\" class=\\\"jp-icon3\\\" role=\\\"img\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"><title>Apache Spark</title><path d=\\\"M10.812 0c-.425.013-.845.215-1.196.605a3.593 3.593 0 00-.493.722c-.355.667-.425 1.415-.556 2.143a551.9 551.9 0 00-.726 4.087c-.027.16-.096.227-.244.273C5.83 8.386 4.06 8.94 2.3 9.514c-.387.125-.773.289-1.114.506-1.042.665-1.196 1.753-.415 2.71.346.422.79.715 1.284.936 1.1.49 2.202.976 3.3 1.47.019.01.036.013.053.019h-.004l1.306.535c0 .023.002.045 0 .073-.2 2.03-.39 4.063-.58 6.095-.04.419-.012.831.134 1.23.317.87 1.065 1.148 1.881.701.372-.204.666-.497.937-.818 1.372-1.623 2.746-3.244 4.113-4.872.111-.133.205-.15.363-.098.349.117.697.231 1.045.347h.001c.02.012.045.02.073.03l.142.042c1.248.416 2.68.775 3.929 1.19.4.132.622.164 1.045.098.311-.048.592-.062.828-.236.602-.33.995-.957.988-1.682-.005-.427-.154-.813-.35-1.186-.82-1.556-1.637-3.113-2.461-4.666-.078-.148-.076-.243.037-.375 1.381-1.615 2.756-3.236 4.133-4.855.272-.32.513-.658.653-1.058.308-.878-.09-1.57-1-1.741a2.783 2.783 0 00-1.235.069c-1.974.521-3.947 1.041-5.918 1.57-.175.047-.26.015-.355-.144a353.08 353.08 0 00-2.421-4.018 4.61 4.61 0 00-.652-.849c-.371-.37-.802-.549-1.227-.536zm.172 3.703a.592.592 0 01.189.211c.87 1.446 1.742 2.89 2.609 4.338.07.118.135.16.277.121 1.525-.41 3.052-.813 4.579-1.217.367-.098.735-.193 1.103-.289a.399.399 0 01-.1.2c-1.259 1.48-2.516 2.962-3.779 4.438-.11.13-.12.22-.04.37.937 1.803 1.768 3.309 2.498 4.76l-3.696-1.019c-.538-.18-1.077-.358-1.615-.539-.163-.055-.25-.03-.36.1-1.248 1.488-2.504 2.97-3.759 4.454a.398.398 0 01-.18.132c.035-.378.068-.757.104-1.136.149-1.572.297-3.144.451-4.716-.03-.318.117-.405-.322-.545-1.493-.593-3.346-1.321-4.816-1.905a.595.595 0 01.24-.134c1.797-.57 3.595-1.14 5.394-1.705.127-.04.199-.092.211-.233.013-.148.05-.294.076-.441.241-1.363.483-2.726.726-4.088.068-.386.14-.771.21-1.157z\\\"/></svg>\";"],"names":[],"sourceRoot":""}